/**
 * Compiler for the SQL language, with semantic actions that support code completion
 */
PACKAGE "net.sourceforge.jcomplete.parser"
IMPORT "net.sourceforge.jcomplete.completions.*", "net.sourceforge.jcomplete.*"

COMPILER squirrelSQL

    public List statements = new ArrayList();
    public SQLSchema rootSchema;

    private Stack statementStack;

    protected void addRootStatement(SQLStatement statement)
    {
        statement.setSqlSchema(rootSchema);
        statements.add(statement);
        statementStack = new Stack();
        statementStack.push(statement);
    }

    private SQLStatement getParent()
    {
        return (SQLStatement)statementStack.peek();
    }

    private void pushStatement(SQLStatement statement)
    {
        SQLStatement parent = (SQLStatement)statementStack.peek();
        parent.addStatement(statement);
        statementStack.push(statement);
    }

    private SQLStatement popStatement()
    {
        return (SQLStatement)statementStack.pop();
    }

IGNORE CASE

CHARACTERS
    tab         = CHR(9) .
    lf          = CHR(10) .
    cr          = CHR(13) .
    cntl        = CHR(0) .. CHR(31) .
    Special     = '"' + "%&'()*+,-./:;<=>?|".
    Digit       = "0123456789".
    Letter      = CHR(33)..CHR(127) - Special - Digit.
    noquote1    = ANY-'"' - cntl.
    noquote2    = ANY-"'" - cntl.

TOKENS
    ident       = Letter { Letter | Digit }.
    intValue    = Digit { Digit }.
    float       = [ Digit { Digit } ] "." Digit { Digit }.
    SQLString   = '"' {noquote1| "'" } '"' | "'" {noquote2|'"' }"'".
    OpenParens  = "(".


IGNORE CHR(1)..CHR(31)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "--" TO cr


PRODUCTIONS

squirrelSQL =
    SQLStatement  { SQLStatement  }
    EOF
    .

SQLStatement            (.  addRootStatement(new SQLStatement(token.pos)); .)
    =
    (SelectStmt | InsertStmt | UpdateStmt | DeleteStmt | CreateStmt | Drop | AlterTable | Transaction)
    [ ";" ]
    .

SelectStmt              (.  pushStatement(new SQLStatement(token.pos)); .)
    =
    (SimpleSelect {SetOperator SimpleSelect})
                        (.  popStatement(); .)
    .

SetOperator
    = ("UNION" | "EXCEPT" | "INTERSECT" | "MINUS") [ "ALL" ]
    .

UpdateStmt =
    "UPDATE"
    Table "SET"
    UpdateFieldList  [WhereClause]
    .

UpdateField =
    ColumnName "=" Expression
    .

UpdateFieldList =
    UpdateField  { ItemSeparator UpdateField  }
    .

InsertStmt =
    "INSERT" "INTO"
    Table  [ OpenParens ColumnList CloseParens  ] 
    (("VALUES" OpenParens FieldList CloseParens) | SelectStmt)
    .

DeleteStmt =
    "DELETE"
    "FROM"
    Table  [ WhereClause  ]
    .

SimpleSelect            (.  SQLSelectStatement stmt = new SQLSelectStatement(t.pos);
                            pushStatement(stmt);
                        .)
    =
    SelectClause
    FromClause
    [WhereClause]
    [GroupByClause] 
    [HavingClause] 
    [OrderByClause]     (. popStatement(); .)
    .

SelectClause            (.  SQLSelectStatement statement = (SQLSelectStatement)getParent();
                            statement.setSelectListStart(scanner.pos);
                        .)
    =
    SYNC "SELECT"
    ["DISTINCT" | "ALL"]
    SelectFieldList     (.  statement.setSelectListEnd(t.pos); .)
    .

FromClause              (.  SQLSelectStatement statement = (SQLSelectStatement)getParent();
                            statement.setFromStart(scanner.pos);
                        .)
    =
    SYNC "FROM"
    FromTableList       (.  statement.setFromEnd(t.pos); .)
    .
        
FromTableList =
    QualifiedTable {(ItemSeparator QualifiedTable) | JoinStmt}
    .
        
QualifiedTable          (.  SQLTable table = new SQLTable(getParent(), t.pos);
                            getParent().addChild(table);
                            boolean wasSet = false;
                        .)
    =
    ident               (.  if(t.val.equals("."))
                                table.schema = token.str;
                            else
                                table.name = token.str;
                        .)
    [ "." ident         (.  table.name = token.str; .)
    ] 
    [
    ["AS"]              (.  table.alias = t.str;
                            wasSet = true;
                            if(getParent().setTable(table) == false)
                                SemError(10);
                        .)
    Alias
    ]                   (.  if(!wasSet && getParent().setTable(table) == false)
                                SemError(10);
                        .)
    .

JoinStmt =
    (CrossJoin | ([JoinType] "JOIN" QualifiedTable [JoinExpr]))
    .

CrossJoin =
    "CROSS" "JOIN" QualifiedTable
    .

JoinType =
    ["NATURAL"] ("INNER" | (("FULL" | "LEFT" | "RIGHT") ["OUTER"]))
    .

JoinExpr =
    ("ON" Expression)
    | ("USING" OpenParens ColumnList CloseParens)
    .

WhereClause             (.  SQLSelectStatement statement = (SQLSelectStatement)getParent();
                            statement.setWhereStart(scanner.pos); .)
    =
    SYNC "WHERE" SearchCondition
                        (.  statement.setWhereEnd(t.pos); .)
    .

GroupByClause           (.  SQLSelectStatement statement = (SQLSelectStatement)getParent();
                            statement.setGroupByStart(scanner.pos); .)
    =
    SYNC "GROUP" "BY" FieldList
                        (.  statement.setGroupByEnd(t.pos); .)
    .

HavingClause            (.  SQLSelectStatement statement = (SQLSelectStatement)getParent();
                            statement.setHavingStart(scanner.pos); .)
    =
    SYNC "HAVING" SearchCondition
                        (.  statement.setHavingEnd(t.pos); .)
    .

OrderByClause           (.  SQLSelectStatement statement = (SQLSelectStatement)getParent();
                            statement.setOrderByStart(scanner.pos); .)
    =
    SYNC "ORDER" "BY" OrderByFldList
                        (.  statement.setOrderByEnd(t.pos); .)
    .

SelectFieldList
    =
    SelectField {ItemSeparator SelectField}
    .

SelectField =
    (Expression ["AS" Alias])
    | "*"
    .

FunctionExpr =
    ("TIMESTAMP" | "UPPER" | "MONTH" | "YEAR")
    OpenParens Expression  { ItemSeparator Expression  } 
    CloseParens
    .
        
ColumnFunction =
    ( "COUNT" | "SUM" | "MAX" | "MIN" | "AVG"  ) 
    OpenParens  
    ("*" | (["DISTINCT"] Expression))
    CloseParens
    .

ColumnList =
    ColumnName {ItemSeparator ColumnName}
    .

ColumnName              (.  SQLColumn column = new SQLColumn(getParent(), t.pos);//System.out.println("SQLCol");
                            getParent().addChild(column);
                            if(scanner.ch == '.')
                                column.setAlias(t.str, t.pos);
                            else
                                column.setColumn(t.str, t.pos);
                        .)
    =
    ident
    [ "."
    (ident              (.  column.setColumn(token.str, token.pos); .)
    | "*"
    )]
    .

SimpleColumnName =
    ident
    .

SimpleColumnList =
    SimpleColumnName  {ItemSeparator SimpleColumnName }
    .

SimpleColumnParam =
    OpenParens SimpleColumnList CloseParens
    .

FieldList =
    Field  { ItemSeparator Field  }
    .

Field =
    ColumnName
    | "NULL"
    | float
    | intValue
    | SQLString
    | Param
    .

Table =
    ident
    .

Alias = 
    ident
    .

OrderByFldList =
    OrderByField  {(ItemSeparator OrderByField)}
    .

OrderByField =
    (ColumnName | intValue)
    [("DESC" | "ASC")]
    .

SearchCondition =
    Expression
    .

Expression =
    SimpleExpression  {Relation SimpleExpression}
    .

SimpleExpression =
    [NotOperator] 
    Term  
    {Operator [NotOperator] Term}
    .

Term =
    ["-"] 
    (
    (Field [TestExpr])
    | 
    ColumnFunction 
    | 
    FunctionExpr 
    | 
    (OpenParens (Expression | SelectStmt) CloseParens)
    )
    .

Param =
    ":" ident
    .

NotOperator =
    "NOT"
    .

Operator =
    MathOperator        
    | WordOperator
    .

MathOperator =
    ( "*" | "/" | "+" | "-"  ) 
    .

WordOperator =
    ("AND" | "OR") 
    .
    
LikeTest =
    "LIKE" (SQLString | Param) ["ESCAPE" SQLString]
    .
    
NullTest =
    "IS" [NotOperator] "NULL"
    .

Relation =
    ( "=" | "<>" | "<" | "<=" | ">" | ">="  ) 
    .

TestExpr =
    NullTest        
    | [NotOperator] (InSetExpr | BetweenExpr | LikeTest)
    .

BetweenExpr =
    "BETWEEN" Field "AND" Field
    .

InSetExpr =
    "IN" OpenParens (FieldList | SelectStmt) CloseParens
    .

Transaction =
    ("COMMIT" | "ROLLBACK") ["WORK"]
    .

len =
    intValue
    .

lenParam =
    OpenParens len CloseParens
    .

precision =
    intValue ItemSeparator intValue
    .

DataType =
    (("CHAR" | "CHARACTER")  lenParam)        
    | 
    ("VARCHAR" lenParam)        
    |
    ("INTEGER" | "INT") 
    | 
    "SMALLINT"
    | 
    ("NUMERIC" OpenParens precision CloseParens  )        
    | 
    "DATE"
    | 
    ("TIME" lenParam)        
    | 
    ("TIMESTAMP" lenParam)
    .

ColumnDefault =
    "DEFAULT"
    (SQLString | intValue  | float)
    .

ColumnDefList =
    ColumnDef  {ItemSeparator ColumnDef}
    .

ColumnDef =
    SimpleColumnName DataType {ColumnDefault | (NotOperator "NULL")}
    .

PrimaryKey =
    "PRIMARY"
    "KEY"
    SimpleColumnParam
    .

RelationName =
    ident
    .

ConstraintName =
    ident
    .
    
ForeignKey =
    "FOREIGN" "KEY" RelationName SimpleColumnParam 
    "REFERENCES" Table  ["MATCH" ("FULL" | "PARTIAL")] 
    {"ON" ("DELETE" | "UPDATE") 
        ("CASCADE" | ("SET" ("NULL" | "DEFAULT")))
        |  
        ("NO" "ACTION") 
    }
    .
Unique =
    "UNIQUE"
    SimpleColumnParam
    .
    
CheckConstraint =
    "CHECK"
    OpenParens Expression CloseParens
    .

CreatePart =
    ColumnDef | PrimaryKey | ForeignKey | Unique | CheckConstraint
    .

CreateStmt =
    "CREATE" (CreateTable | CreateIndex)
    .

CreateTable =
    "TABLE" Table OpenParens CreatePart {ItemSeparator CreatePart} CloseParens
    .

CascadeRestrict =
    ("CASCADE" | "RESTRICT") 
    .

Drop =
    "DROP" (DropTable | IndexAndName)
    .

DropTable =
    "TABLE" QualifiedTable  [CascadeRestrict]
    .

Add =
    "ADD" ( 
        ColumnDefList 
        | PrimaryKey 
        | ForeignKey 
        | Unique 
        | CheckConstraint)
    .

Alter =
    "ALTER"
    SimpleColumnName (("DROP" "DEFAULT") |  ("SET" ColumnDefault))
    .
    
DropPart =
    "DROP" (
        (SimpleColumnName CascadeRestrict) 
        | ("PRIMARY" "KEY") 
        | ("FOREIGN" "KEY" RelationName) 
        | ("CONSTRAINT" ConstraintName CascadeRestrict))
    .

AlterTable =
    "ALTER" "TABLE" QualifiedTable (Add | Alter | DropPart)
    .

IndexColumn =
    SimpleColumnName [("ASC" | "DESC")]
    .

IndexColumnList =
    IndexColumn {ItemSeparator IndexColumn}
    .

IndexName =
    ident
    .

CreateIndex =
    ["UNIQUE"] IndexAndName "ON" Table OpenParens IndexColumnList CloseParens
    .

IndexAndName =
    "INDEX" IndexName
    .

ItemSeparator =
    WEAK ","
    .

CloseParens =
        WEAK ")"
        .

END squirrelSQL.
